/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useEffect, useMemo, useRef } from 'react'
import { useGLTF, useTexture } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { useFrame } from '@react-three/fiber'
import gsap from 'gsap'

type SkateboardProps = {
    constantWheelSpin?: boolean, //optional
    pose?: "upright" | "side",
    wheelTextureURLs: string[],
    wheelTextureURL: string,
    deckTextureURLs: string[],
    deckTextureURL: string,
    truckColour: string,
    boltColour: string
}

type GLTFResult = GLTF & {
  nodes: {
    GripTape: THREE.Mesh
    Wheel1: THREE.Mesh
    Wheel2: THREE.Mesh
    Deck: THREE.Mesh
    Wheel4: THREE.Mesh
    Bolts: THREE.Mesh
    Wheel3: THREE.Mesh
    Baseplates: THREE.Mesh
    Truck1: THREE.Mesh
    Truck2: THREE.Mesh
  }
  materials: object
}
//this function was called Model by default, changed it it Skateboard
export function Skateboard({pose="upright", constantWheelSpin=false, wheelTextureURLs, wheelTextureURL, deckTextureURLs, deckTextureURL, truckColour, boltColour}:SkateboardProps) {
  const { nodes, materials } = useGLTF('/skateboard.gltf') as GLTFResult


    //TEXTURES
    ///griptape
    const gripTapeDiffuse = useTexture("/skateboard/griptape-diffuse.webp"); //colour
    const gripTapeRoughness = useTexture("/skateboard/griptape-roughness.webp"); //bumpmap
    
    //dont recreate this material on every render, only first
    const gripTapeMaterial = useMemo(() => {
        //create a material with these settings
        const material = new THREE.MeshStandardMaterial({
            map: gripTapeDiffuse, //image instead of block color
            bumpMap: gripTapeRoughness, //bumpmap
            roughnessMap: gripTapeRoughness, //shiny map (uses black/white img like bumpmap but for shiny levels instead)
            bumpScale: 3.5,
            roughness: .8, //overall shiney level //lower = shiney
            color: "#555555"
        });

        //enable repeat on x/y for the material (default stretches across full mesh)
        if(gripTapeDiffuse){
            gripTapeDiffuse.wrapS = THREE.RepeatWrapping; //x repeat forever (1000)
            gripTapeDiffuse.wrapT = THREE.RepeatWrapping; //y repeat forever (1000)
            gripTapeDiffuse.repeat.set(9 ,9);
            gripTapeDiffuse.needsUpdate = true; //update after change

            gripTapeRoughness.wrapS = THREE.RepeatWrapping; //x repeat forever (1000)
            gripTapeRoughness.wrapT = THREE.RepeatWrapping; //y repeat forever (1000)
            gripTapeRoughness.repeat.set(9 ,9); //repeat this many times x/y
            gripTapeRoughness.needsUpdate = true; //update after change

            gripTapeRoughness.anisotropy = 8; //control blur/smoothing at weird angles (keep it rough)
        }

        return material;
    }, [gripTapeDiffuse, gripTapeRoughness]);



    //bolts
    //const boltColour = "#555555"; //already passed in
    const boltMaterial = useMemo(() => //shorthand, just return like this instead (implicit)
       new THREE.MeshStandardMaterial({
            color: boltColour, //block color
            metalness: .5, 
            roughness: .3 //overall shiney level //lower = shiney
        })
    , [boltColour]);


    //trucks
    const metalNormal = useTexture("/skateboard/metal-normal.avif"); //normal map (like bump maps but for lighting)
    metalNormal.wrapS = THREE.RepeatWrapping; //reeapt x repeat forever (1000)
    metalNormal.wrapT = THREE.RepeatWrapping; //repeat y repeat forever (1000)
    metalNormal.anisotropy = 8; //control blur/smoothing at weird angles 
    metalNormal.repeat.set(8, 9); //repeat this many times x/y

    //const truckColour = "#555555"; already passed in
    const truckMaterial = useMemo(() => //shorthand, just return like this instead (implicit)
        new THREE.MeshStandardMaterial({
            color: truckColour, //block color
            normalMap: metalNormal, //normal map (like bump maps but for lighting)
            normalScale: new THREE.Vector2(.3, .3), //xy values
            metalness: .8, 
            roughness: .25 //overall shiney level //lower = shiney
        })
    , [truckColour, metalNormal]);



    //deck
    //all wheel textures (array)
    const deckTextures = useTexture(deckTextureURLs);
    deckTextures.forEach(texture => {
        texture.flipY = false; //prevent texture flip
        texture.colorSpace = THREE.SRGBColorSpace; //colour correction
    });
    const deckTextureIndex = deckTextureURLs.findIndex(url => url === deckTextureURL); //get index position (1,2 etc)
    const deckTexture = deckTextures[deckTextureIndex]; //use that "index" to get it out of deckTextures array

    //const deckTexture = useTexture("/skateboard/Deck.webp"); 
    //deckTexture.flipY = false; //do not flip texture
    const deckMaterial = useMemo(() => //shorthand, just return like this instead (implicit)
        new THREE.MeshStandardMaterial({         
            map:deckTexture, //image instead of block color
            roughness: .1 //overall shiney level //lower = shiney
        })
    , [deckTexture]);



    //wheels
    //all wheel textures (array)
    const wheelTextures = useTexture(wheelTextureURLs);
    wheelTextures.forEach(texture => {
        texture.flipY = false; //prevent texture flip
        texture.colorSpace = THREE.SRGBColorSpace; //colour correction
    });
    const wheelTextureIndex = wheelTextureURLs.findIndex(url => url === wheelTextureURL); //get index position (1,2 etc)
    const wheelTexture = wheelTextures[wheelTextureIndex]; //use that "index" to get it out of wheelTextures array

    //const wheelTexture = useTexture("/skateboard/SkateWheel1.png");
    //wheelTexture.flipY = false; //do not flip texture
    const wheelsMaterial = useMemo(() => //shorthand, just return like this instead (implicit)
        new THREE.MeshStandardMaterial({         
            map:wheelTexture, //image instead of block color
            roughness: .35 //overall shiney level //lower = shiney
        })
    , [wheelTexture]);





    //SPIN WHEELS
    const wheelRefs = useRef<THREE.Object3D[]>([]); //is type of 3D, in an array
    //make an array that holds all wheels (refs added to html)
    const addToWheelRefs = (ref: THREE.Object3D | null) => {
        if(ref && !wheelRefs.current.includes(ref)){ //add to array if it doesnt exist
            wheelRefs.current.push(ref);
        }
    }   

    //constant spin (three.js)
    useFrame(() => { //useFrame from three-fibre (
        if(!wheelRefs.current || !constantWheelSpin) return; //if no refs, or constantWheelSpin is false, stop here
        for(const wheel of wheelRefs.current){ //loop over each wheel in array
            wheel.rotation.x +=.2; //spin!
        }
    });

    //small spin (gsap)
    useEffect(() => {
        if(!wheelRefs.current || constantWheelSpin) return; //if no refs, or constantWheelSpin is true, stop here
        for(const wheel of wheelRefs.current){ //loop over each wheel in array
          //gsap rotation
          gsap.to(wheel.rotation, {x:"-=30", duration:2.5, ease:"circ.out"}); //slowly stop
        }
    }, [constantWheelSpin, wheelTextureURL]);

    
    const positions = useMemo(() =>  (
      {
        upright: {
          rotation: [0, 0, 0],
          position: [0, 0, 0]
        },
        side: {
          rotation: [0, 0, Math.PI/2], //rotate a quarter
          position: [0, 0.295, 0] //move up a bit
        },
      }) as const , []   
    )


  return (
    //this had {...props} that we removed}
    <group dispose={null} rotation={positions[pose].rotation} position={positions[pose].position}>
      <group name="Scene">
        <mesh
          name="GripTape"
          castShadow
          receiveShadow
          geometry={nodes.GripTape.geometry}
          material={gripTapeMaterial} //use one we created above
          position={[0, 0.286, -0.002]}
        />
        <mesh
          name="Wheel1"
          castShadow
          receiveShadow
          geometry={nodes.Wheel1.geometry}
          material={wheelsMaterial}
          position={[0.238, 0.086, 0.635]}
          ref={addToWheelRefs}
        />
        <mesh
          name="Wheel2"
          castShadow
          receiveShadow
          geometry={nodes.Wheel2.geometry}
          material={wheelsMaterial}
          position={[-0.237, 0.086, 0.635]}
          ref={addToWheelRefs}
        />
        <mesh
          name="Wheel3"
          castShadow
          receiveShadow
          geometry={nodes.Wheel3.geometry}
          material={wheelsMaterial}
          position={[0.237, 0.086, -0.635]}
          rotation={[Math.PI, 0, Math.PI]}
          ref={addToWheelRefs}
        />
        <mesh
          name="Wheel4"
          castShadow
          receiveShadow
          geometry={nodes.Wheel4.geometry}
          material={wheelsMaterial}
          position={[-0.238, 0.086, -0.635]}
          rotation={[Math.PI, 0, Math.PI]}
          ref={addToWheelRefs}
        />
        <mesh
          name="Deck"
          castShadow
          receiveShadow
          geometry={nodes.Deck.geometry}
          material={deckMaterial} //use one we created above
          position={[0, 0.271, -0.002]}
        />
        <mesh
          name="Bolts"
          castShadow
          receiveShadow
          geometry={nodes.Bolts.geometry}
          material={boltMaterial} //use one we created above
          position={[0, 0.198, 0]}
          rotation={[Math.PI, 0, Math.PI]}
        />
        <mesh
          name="Baseplates"
          castShadow
          receiveShadow
          geometry={nodes.Baseplates.geometry}
          material={truckMaterial} //use one we created above
          position={[0, 0.211, 0]}
        />
        <mesh
          name="Truck1"
          castShadow
          receiveShadow
          geometry={nodes.Truck1.geometry}
          material={truckMaterial} //use one we created above
          position={[0, 0.101, -0.617]}
        />
        <mesh
          name="Truck2"
          castShadow
          receiveShadow
          geometry={nodes.Truck2.geometry}
          material={truckMaterial} //use one we created above
          position={[0, 0.101, 0.617]}
          rotation={[Math.PI, 0, Math.PI]}
        />
      </group>
    </group>
  )
}

useGLTF.preload('/skateboard.gltf')
